"""
AI Emergency Caller - Twilio Voice Integration (REST API Direct)
================================================================
Makes REAL phone calls using Twilio's REST API directly via `requests`.
No `twilio` pip package required - avoids Windows path-length issues.
"""

import os
import logging
import uuid
import requests
from datetime import datetime
from typing import Dict, Optional

logger = logging.getLogger(__name__)


class AIEmergencyCaller:
    """
    Makes real phone calls to emergency contacts using Twilio REST API.
    Delivers a dynamic text-to-speech briefing about the disaster.
    """

    TWILIO_API_BASE = "https://api.twilio.com/2010-04-01/Accounts"

    def __init__(self):
        self.account_sid = os.environ.get("TWILIO_ACCOUNT_SID", "")
        self.auth_token = os.environ.get("TWILIO_AUTH_TOKEN", "")
        self.twilio_number = os.environ.get("TWILIO_PHONE_NUMBER", "")
        self.call_log = []

        if self.account_sid and self.auth_token and self.twilio_number:
            print("[AI Caller] Twilio credentials loaded - REAL CALLS ENABLED")
        else:
            print("[AI Caller] Twilio credentials not set - simulation mode")

    @property
    def is_ready(self) -> bool:
        return bool(self.account_sid and self.auth_token and self.twilio_number)

    def _build_twiml(self, disaster_type: str, location_name: str,
                     lat: float, lng: float, patient_count: int,
                     severity: str, hospitals_nearby: int = 0,
                     ambulances_dispatched: int = 0) -> str:
        """Build dynamic TwiML voice script for the emergency call."""

        severity_words = {
            "CRITICAL": "critical, life-threatening",
            "HIGH": "high severity",
            "MEDIUM": "moderate severity",
            "LOW": "low severity"
        }
        sev_desc = severity_words.get(severity, "unknown severity")

        disaster_names = {
            "FIRE": "fire emergency",
            "FLOOD": "flooding emergency",
            "EARTHQUAKE": "earthquake emergency",
            "ACCIDENT": "major traffic accident",
            "CHEMICAL_SPILL": "chemical spill hazard",
            "BUILDING_COLLAPSE": "building collapse emergency"
        }
        disaster_desc = disaster_names.get(disaster_type, "disaster emergency")

        script = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Pause length="1"/>
    <Say voice="Polly.Matthew" language="en-US">
        This is an automated emergency alert from the S.A.V.E. Disaster Response System.
    </Say>
    <Pause length="1"/>
    <Say voice="Polly.Matthew" language="en-US">
        A {disaster_desc} of {sev_desc} level has been reported
        at coordinates {lat:.3f} latitude, {lng:.3f} longitude,
        near {location_name}.
    </Say>
    <Pause length="1"/>
    <Say voice="Polly.Matthew" language="en-US">
        Approximately {patient_count} patients require immediate medical attention.
        {hospitals_nearby} hospitals have been identified in the vicinity.
        {ambulances_dispatched} ambulance units have been dispatched by the AI coordination system.
    </Say>
    <Pause length="1"/>
    <Say voice="Polly.Matthew" language="en-US">
        All emergency response teams are requested to activate their disaster protocols immediately.
        This alert was generated by the Strategic Agent-based Victim Evacuation system.
        Repeating: {patient_count} patients, {sev_desc} {disaster_desc}, location near {location_name}.
    </Say>
    <Pause length="1"/>
    <Say voice="Polly.Matthew" language="en-US">
        End of automated emergency alert. Thank you.
    </Say>
</Response>"""
        return script

    def make_emergency_call(self, to_number: str, disaster_type: str,
                            location_name: str, lat: float, lng: float,
                            patient_count: int, severity: str,
                            hospitals_nearby: int = 0,
                            ambulances_dispatched: int = 0) -> Dict:
        """
        Make an actual phone call to deliver the emergency briefing.
        Uses Twilio REST API directly (no pip package needed).
        """
        twiml_script = self._build_twiml(
            disaster_type, location_name, lat, lng,
            patient_count, severity, hospitals_nearby, ambulances_dispatched
        )

        call_record = {
            "timestamp": datetime.now().isoformat(),
            "to_number": to_number,
            "disaster_type": disaster_type,
            "location": location_name,
            "patients": patient_count,
            "severity": severity,
            "script": twiml_script,
        }

        if not self.is_ready:
            # SIMULATION MODE
            sim_sid = f"SIM-{str(uuid.uuid4())[:12]}"
            call_record["status"] = "completed (simulated)"
            call_record["call_sid"] = sim_sid
            call_record["error"] = None
            self.call_log.append(call_record)
            return call_record

        # --- REAL TWILIO CALL via REST API ---
        try:
            url = f"{self.TWILIO_API_BASE}/{self.account_sid}/Calls.json"
            data = {
                "Twiml": twiml_script,
                "To": to_number,
                "From": self.twilio_number,
            }
            response = requests.post(
                url,
                data=data,
                auth=(self.account_sid, self.auth_token),
                timeout=15
            )

            if response.status_code in (200, 201):
                result = response.json()
                call_record["status"] = result.get("status", "queued")
                call_record["call_sid"] = result.get("sid", "")
                call_record["error"] = None
                print(f"[AI Caller] REAL CALL initiated: SID={result.get('sid')}, To={to_number}")
            else:
                error_body = response.json() if response.headers.get("content-type", "").startswith("application/json") else {"message": response.text}
                call_record["status"] = "failed"
                call_record["call_sid"] = None
                call_record["error"] = f"HTTP {response.status_code}: {error_body.get('message', response.text)}"
                print(f"[AI Caller] Call FAILED: {call_record['error']}")

        except Exception as e:
            call_record["status"] = "failed"
            call_record["error"] = str(e)
            call_record["call_sid"] = None
            print(f"[AI Caller] Call exception: {e}")

        self.call_log.append(call_record)
        return call_record

    def get_call_status(self, call_sid: str) -> Optional[Dict]:
        """Check status of a previously initiated call via REST API."""
        if not self.is_ready or not call_sid or call_sid.startswith("SIM-"):
            return {"status": "unknown", "error": "Client not ready or simulated SID"}

        try:
            url = f"{self.TWILIO_API_BASE}/{self.account_sid}/Calls/{call_sid}.json"
            response = requests.get(
                url,
                auth=(self.account_sid, self.auth_token),
                timeout=10
            )
            if response.status_code == 200:
                result = response.json()
                return {
                    "call_sid": result.get("sid"),
                    "status": result.get("status"),
                    "duration": result.get("duration"),
                    "direction": result.get("direction"),
                    "start_time": result.get("start_time"),
                    "end_time": result.get("end_time"),
                }
            else:
                return {"status": "error", "error": f"HTTP {response.status_code}"}
        except Exception as e:
            return {"status": "error", "error": str(e)}

    def get_call_log(self):
        """Return all call records."""
        return self.call_log


# Global instance
ai_caller = AIEmergencyCaller()
